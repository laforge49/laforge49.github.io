<!DOCTYPE html>
<html>
<body>
<h1>Project Metadata</h1>
<p>I've got too many projects, many of them quite old.
So here are some notes to help you out.</p>
<h2>
<a href="https://groups.google.com/forum/?hl=en#!forum/agilewikidevelopers">AgileWikiDevelopers</a>
</h2>
<p>
A Google Group that you are free to join,
AgileWikiDevelopers covers a number of advanced topics, 
as well as being a place for me to chat about 
what I am working on.
</p>
<h2>
<a href="https://github.com/laforge49/JActor2">JActor2</a>
</h2>
<p>
JActor2 is a multi-threaded OO programming model, 
inspired by Alan Kay's early thoughts on Objects. 
JActor2 is based on asynchronous 2-way messaging with assured responses. 
The net result being code that is both simpler and more robust, and hence easier to maintain.
</p>
<p>
Getting close to a 1.0 release.
</p>
<h2>
<a href="https://github.com/laforge49/util">util</a>
</h2>
<p>
A brand new project for various Java utility classes.
</p>
<h3>
org.agilewiki.utils.cache
</h3>
<p>
How do you write a cache that can be used across multiple threads?
The class java.util.LinkedHashMap is a pretty good cache, but it is not thread safe.
And adding a bunch of synchronization locks might not be the fastest way to handle caching in a thread-safe way.
</p>
<p>
The solution provided here is to have a separate cache for each thread, but to track all cache entries in a concurrent
weak-valued hash map. If any cache has an entry for a given key, 
then the concurrent hash map will have a weak reference to that entry with the same key.
A cache then returns a value when either it has an entry for a given key 
or when the concurrent hash map has a non-empty weak reference for that key. 
</p>
<p>
Performance then is gained by only having a sync lock (in ConcurrentHashMap)
when adding an entry to a cache.
</p>
<h2>
<a href="https://github.com/laforge49?tab=repositories">Other Projects</a>
</h2>
<p>
I have not listed all of the projects above. Some are quite old, others moderately current.
</p>
</body>
</html>
